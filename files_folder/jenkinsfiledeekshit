# ============= deekshit detail explnation jenkins file ==========================

pipeline{
    agent any 
    environment{
        VERSION = "${env.BUILD_ID}"  #this env variable isunder env and under this build id , we can declare env varibles under pipeline
                                    #which build is we mention , that build is created as image during docker stage , like this updated buld is converted to new artifactory image.
    }
    stages{
        stage("sonar quality check"){
            agent {                                     
                docker {                                        # differnt teams use diff soanr / mvn versions , so use docker as agnet with 
                    image 'openjdk:11'                           #   that version
                                                            # sonar plugin add in jenkins- then add sonar credentilas in jenkins- configure syetem in jenkins , so  that jenkins& sonar can communicate to validate code scanning
                }
            }
            steps{
                script{                                                      #sonar-token is name that we gave at time of token generated
                    withSonarQubeEnv(credentialsId: 'sonar-token') {           #  this can be generated by pipeline genearator 
                            sh 'chmod +x gradlew'                                 #we give permisions to gradlew file         
                            sh './gradlew sonarqube'                        #this code is reviewwd by sonar and give results, we provide jenkins url in sonar webhook , so that   sonar send auality gate results to jenkins.
                    }

                    timeout(time: 1, unit: 'HOURS') {                          # by usong timeoutsnippet generator
                      def qg = waitForQualityGate()
                      if (qg.status != 'OK') {
                           error "Pipeline aborted due to quality gate failure: ${qg.status}"
                      }
                    }

                }  
            }
        }                                                                           
        # go to nexus and create  repository  as docker repository, enable http 8083, then go to  jenkins  server and configure nexus as insecure registery, login to jenins server and check for insecure registry 
        #by usinig "docker info", see deekshit wiki page for nexus connfiguration with jenkins.
        stage("docker build & docker push"){
            steps{
                script{
                    withCredentials([string(credentialsId: 'docker_pass', variable: 'docker_password')]) {   # while we storeing docker user name and password in jenkins credentilas these names/variableswe assign , so we gave same names there 
                             sh '''
                                docker build -t 34.125.214.226:8083/springapp:${VERSION} .  #by this docker build image in  this nexus server under that name(springapp)
                                                                                              # check this VERSIN UNDER ENV VARIBLES ON TOP
                                docker login -u admin -p $docker_password 34.125.214.226:8083 
                                docker push  34.125.214.226:8083/springapp:${VERSION}
                                docker rmi 34.125.214.226:8083/springapp:${VERSION}  #to remove older builds
                            '''
                    }
                }
            }
        }
        # enable email extension in jenkins - manage plugin -and then jenkins-configure system- email sections- 

        stage('indentifying misconfigs using datree in helm charts'){    # in CI stage itself we find misconfigurations, schema rules violations.
            steps{
                script{

                    dir('kubernetes/') {  #we are telling that files are in this (kubernetes/) directory, snippet generator  you can do write this command
                        withEnv(['DATREE_TOKEN=GJdx2cP2TCDyUY3EhQKgTc']) { # to set/ enable datree rules , so based on these rules , it will check our directory; this token is we can find in data tree page , under settings, by doing this jenkins can have access  waith data tree and give code to data tree
                              sh 'helm datree test myapp/'   #in this folder (myapp/) all files are cheked by datree for misconfigurations ; this is command to check data tree misconfigurations 
                        }
                    }
                }
            }
        }
        # helm show chart  .\foldername\     it tells details  of helm chart ; we can see helm versions in chart .yaml file
        stage("pushing the helm charts to nexus"){     # we are sending these helm charts  to nexus repository and 
            steps{
                script{
                    withCredentials([string(credentialsId: 'docker_pass', variable: 'docker_password')]) {  # these are   names as we mentioned in jenkins credentials page for the nexus connecting
                          dir('kubernetes/') {
                             sh '''
                                 helmversion=$( helm show chart myapp | grep version | cut -d: -f 2 | tr -d ' ')  # this command is bash command, we take variable ( helmversion), helm show chart foldernmae ; it shows helm details, then by using grep command , delimitor we get helm version 
                                                                                                                            # tr -d '' is to eliminate spaces if we have  version: 0.2.1; after delimitor there is space, to eliminate thta we use tr -d ''
                                 tar -czvf  myapp-${helmversion}.tgz myapp/  # take this folder ( myapp) and create tar for this folder 
                                 curl -u admin:$docker_password http://34.125.214.226:8081/repository/helm-hosted/ --upload-file myapp-${helmversion}.tgz -v  
            # we create this repo (helm-hosted) in  nexus repository
            # these (helm-hosted)  repository now we send to nexus , to uplaod file we use coommand   " --upload-file myapp-${helmversion}.tgz -v " to send to nexus
                            '''
                          }
                    }
                }
            }
        }

        stage('manual approval'){  
            steps{
                script{
                    timeout(10) {
                        mail bcc: '', body: "<br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> Go to build url and approve the deployment request <br> URL de build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: '', mimeType: 'text/html', replyTo: '', subject: "${currentBuild.result} CI: Project name -> ${env.JOB_NAME}", to: "deekshith.snsep@gmail.com";  
                        input(id: "Deploy Gate", message: "Deploy ${params.project_name}?", ok: 'Deploy')
                    }
                }
            }
        }
# now to connect k8 master server  from jenins, we need copy k8 master key, for this go to k8 master , cd .kubeconfig, cat kubeconfig, you see key, copy it, now go to jenkins server and install kubernetes continuos deploy plugin
# then jenkins- manage credentilas - ad global credentilas - add this key under kubernetes configuration, there we can give direclty  enter key, or we can give path of kube config where it is in  k8 master , like /home/kubeconfig , copy to jenkins master 
#then that location path form jenkins master ,  we give that details under "file from jenkins master"
# direclty we can give kubeconfig path from k8 master node , but we use ssh configurations for this set up under this  jenins credntails-kube configuration block
# to pull images from nexus by the k8 , we need to  create k8 secret in k8 server and this is command, and check wiki page 
# kubectl create secret docker-registry registry-secret --docker-server=nexus_machine_ip_only:8083 --docker-username=admin --docker-password=admin --docker-email=not-needed@example.com
# this is enter in master node; "registry-secret" is secret name; this secret nameis referred into deployment .yaml file under image pull secrets, 

        stage('Deploying application on k8s cluster') {
            steps {
               script{
                   withCredentials([kubeconfigFile(credentialsId: 'kubernetes-config', variable: 'KUBECONFIG')]) {  #we are authenticating k8 cluster from jenkins file if it is connecting to k8 cluster or not, we are giving kube config path for security key insted of directly we are giving here
                        dir('kubernetes/') {
                          sh 'helm upgrade --install --set image.repository="34.125.214.226:8083/springapp" --set image.tag="${VERSION}" myjavaapp myapp/ ' 
                        }   #if already versin is avilabe, then upgrade do, if not there, then it go for install 
                           # and also to get images from nexus by k8 , we need to authenticate 
                    }
               }
            }
        }

        stage('verifying app deployment'){
            steps{
                script{
                     withCredentials([kubeconfigFile(credentialsId: 'kubernetes-config', variable: 'KUBECONFIG')]) {
                         sh 'kubectl run curl --image=curlimages/curl -i --rm --restart=Never -- curl myjavaapp-myapp:8080'  #this command is to verify whether our deploy image is woringor not by usng curl command
                            # to verify the application is correctly working fine or not.
                             
                     }
                }
            }
        }
    }

    post { 
		always {
			mail bcc: '', body: "<br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> URL de build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: '', mimeType: 'text/html', replyTo: '', subject: "${currentBuild.result} CI: Project name -> ${env.JOB_NAME}", to: "deekshith.snsep@gmail.com";  
		 }
	   }
}
